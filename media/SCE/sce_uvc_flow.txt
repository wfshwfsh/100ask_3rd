
from linux/drivers/media/video/uvc/uvc_driver.c

static struct usb_device_id uvc_ids[] = {
	/* LogiLink Wireless Webcam */
	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
				| USB_DEVICE_ID_MATCH_INT_INFO,
	  .idVendor		= 0x0416,
	  .idProduct		= 0xa91a,
	  .bInterfaceClass	= USB_CLASS_VIDEO,
	  .bInterfaceSubClass	= 1,
	  .bInterfaceProtocol	= 0,
	  .driver_info		= UVC_QUIRK_PROBE_MINMAX },
	/* Genius eFace 2025 */
	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
	...
	
	}
	


uvc_init
	usb_register(&uvc_driver.driver);
		
		
struct uvc_driver uvc_driver = {
	.driver = {
		.name		= "uvcvideo",
		.probe		= uvc_probe,
		.disconnect	= uvc_disconnect,
		.suspend	= uvc_suspend,
		.resume		= uvc_resume,
		.reset_resume	= uvc_reset_resume,
		.id_table	= uvc_ids,
		.supports_autosuspend = 1,
	},
};
	
uvc_probe
	struct usb_device *udev = interface_to_usbdev(intf);
	struct uvc_device *dev;	
	
	if (id->idVendor && id->idProduct)
		uvc_trace(UVC_TRACE_PROBE, "Probing generic UVC device %s\n",
				udev->devpath);
	
	dev = kzalloc(sizeof *dev, GFP_KERNEL)

	dev->udev = usb_get_dev(udev);
	dev->intf = usb_get_intf(intf);
	dev->intfnum = intf->cur_altsetting->desc.bInterfaceNumber;
	
	
	uvc_parse_control(dev) //分析控制描述符

	v4l2_device_register(&intf->dev, &dev->vdev)
	
	
	/* Initialize controls. */
	uvc_ctrl_init_device(dev) < 0

	/* Scan the device for video chains. */
	uvc_scan_device(dev) < 0

	/* Register video device nodes. */
	uvc_register_chains(dev) < 0
		list_for_each_entry(chain, &dev->chains, list) {
		ret = uvc_register_terms(dev, chain);
			list_for_each_entry(term, &chain->entities, chain) {
				stream = uvc_stream_by_id(dev, term->id);
				stream->chain = chain;
				ret = uvc_register_video(dev, stream);
					struct video_device *vdev;
					uvc_video_init(stream);
					uvc_debugfs_init_stream(stream);
					
					/* Register the device with V4L. */
					vdev = video_device_alloc();
					
					vdev->v4l2_dev = &dev->vdev;
					vdev->fops = &uvc_fops;//fops !!!
					vdev->release = uvc_release;
					strlcpy(vdev->name, dev->name, sizeof vdev->name);
					
					
					/* Set the driver data before calling video_register_device, otherwise
					* uvc_v4l2_open might race us.
					*/
					stream->vdev = vdev;
					video_set_drvdata(vdev, stream);
	
					ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
					
				term->vdev = stream->vdev;
			}
		
	/* Save our data pointer in the interface data. */
	usb_set_intfdata(intf, dev);

	/* Initialize the interrupt URB. */
	if ((ret = uvc_status_init(dev)) < 0) {
		uvc_printk(KERN_INFO, "Unable to initialize the status "
			"endpoint (%d), status interrupt will not be "
			"supported.\n", ret);
	}

	uvc_trace(UVC_TRACE_PROBE, "UVC device initialized.\n");
	usb_enable_autosuspend(udev);
	
error:
	uvc_unregister_video(dev);


22222222222222222222222222222222222 分析控制描述符
uvc_parse_control(dev)
	struct usb_host_interface *alts = dev->intf->cur_altsetting;
	unsigned char *buffer = alts->extra;
	int buflen = alts->extralen;
	
	while (buflen > 2) {
		if (uvc_parse_vendor_control(dev, buffer, buflen) ||
		buffer[1] != USB_DT_CS_INTERFACE)
		
		if ((ret = uvc_parse_standard_control(dev, buffer, buflen)) < 0)
			uvc_parse_standard_control
				switch (buffer[2]) {
				case UVC_VC_HEADER:
					uvc_parse_streaming
						/* Parse the header descriptor. */
						switch (buffer[2]) {
						case UVC_VS_OUTPUT_HEADER:
							streaming->type = V4L2_BUF_TYPE_VIDEO_OUTPUT; //對應VIDIOC_QUERYCAP
							size = 9;
						case UVC_VS_INPUT_HEADER:
							streaming->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
							size = 13;
						...
						/* Count the format and frame descriptors. */
						while (_buflen > 2 && _buffer[1] == USB_DT_CS_INTERFACE) {
							switch (_buffer[2]) {
							case UVC_VS_FORMAT_UNCOMPRESSED:
							case UVC_VS_FORMAT_MJPEG:
							case UVC_VS_FORMAT_FRAME_BASED:

							case UVC_VS_FORMAT_MPEG2TS:
							case UVC_VS_FORMAT_STREAM_BASED:
								uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
									"interface %d FORMAT %u is not supported.\n",
									dev->udev->devnum,
									alts->desc.bInterfaceNumber, _buffer[2]);
								break;

							case UVC_VS_FRAME_UNCOMPRESSED:
							case UVC_VS_FRAME_MJPEG:
							...
						}
						
						...
						frame = (struct uvc_frame *)&format[nformats];
						interval = (__u32 *)&frame[nframes];

						streaming->format = format;
						streaming->nformats = nformats;


						/* Parse the format descriptors. */
						while (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE) {
							switch (buffer[2]) {
							case UVC_VS_FORMAT_UNCOMPRESSED:
							case UVC_VS_FORMAT_MJPEG:
							case UVC_VS_FORMAT_DV:
							case UVC_VS_FORMAT_FRAME_BASED:
								format->frame = frame;
								ret = uvc_parse_format(dev, streaming, format,
									&interval, buffer, buflen);
								if (ret < 0)
									goto error;

								frame += format->nframes;
								format++;

								buflen -= ret;
								buffer += ret;
								continue;

							default:
								break;
							}

							buflen -= buffer[0];
							buffer += buffer[0];
						}

	
						
				case UVC_VC_INPUT_TERMINAL:  ...
				case UVC_VC_OUTPUT_TERMINAL: ...
				case UVC_VC_SELECTOR_UNIT:   ...
				case UVC_VC_PROCESSING_UNIT: ...
				case UVC_VC_EXTENSION_UNIT:  ...
		
	next_descriptor:
		buflen -= buffer[0];
		buffer += buffer[0];
	}







const struct v4l2_file_operations uvc_fops = {
	.owner		= THIS_MODULE,
	.open		= uvc_v4l2_open,
	.release	= uvc_v4l2_release,
	.unlocked_ioctl	= uvc_v4l2_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl32	= uvc_v4l2_compat_ioctl32,
#endif
	.read		= uvc_v4l2_read,
	.mmap		= uvc_v4l2_mmap,
	.poll		= uvc_v4l2_poll,
#ifndef CONFIG_MMU
	.get_unmapped_area = uvc_v4l2_get_unmapped_area,
#endif
};

1. open
	uvc_v4l2_open(struct file *file)
	struct uvc_streaming *stream;
	struct uvc_fh *handle;
	stream = video_drvdata(file);
	usb_autopm_get_interface(stream->dev->intf);

	/* Create the device handle. */
	handle = kzalloc(sizeof *handle, GFP_KERNEL);

	ret = uvc_status_start(stream->dev);

	handle->chain = stream->chain;
	handle->stream = stream;
	handle->state = UVC_HANDLE_PASSIVE;
	file->private_data = handle;

2. VIDIOC_QUERYCAP
	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
		cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
				  
	else
		cap->capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;

3. VIDIOC_ENUM_FMT
	struct uvc_fh *handle = file->private_data;
	struct uvc_streaming *stream = handle->stream;
	struct v4l2_fmtdesc *fmt = arg;
	struct uvc_format *format;
	format = &stream->format[fmt->index]; /*從數組中取出*/
	...
	strlcpy(fmt->description, format->name,
			sizeof fmt->description);
	...

4. VIDIOC_G_FMT
	return uvc_v4l2_get_format(stream/*video*/, arg/*fmt*/);
		fmt->fmt.pix.pixelformat = video->fcc;
		fmt->fmt.pix.width = video->width;
		fmt->fmt.pix.height = video->height;
		fmt->fmt.pix.field = V4L2_FIELD_NONE;
		fmt->fmt.pix.bytesperline = video->bpp * video->width / 8;
		fmt->fmt.pix.sizeimage = video->imagesize;
		fmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
		fmt->fmt.pix.priv = 0;
	
5. VIDIOC_S_FMT
	
	
	
6. VIDIOC_QUERYCTRL

7. VIDIOC_REQBUFS

VIDIOC_QUERYBUF 
VIDIOC_QBUF
VIDIOC_DQBUF
VIDIOC_STREAMON
VIDIOC_STREAMOFF




